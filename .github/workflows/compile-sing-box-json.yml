name: Compile sing-box JSON rules

on:
  push:
    branches:
      - main

permissions:
  contents: write  # allow the workflow to push commits and tags back to the repo

jobs:
  compile-json:
    name: Compile changed JSON rule-sets
    runs-on: ubuntu-latest
    env:
      # sing-box 可执行文件路径（在仓库 bin 目录下）
      SING_BOX: ./bin/sing-box
      DEFAULT_BRANCH: main

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # need full history & tags for diff

      - name: Ensure this is a plain push (no tag)
        run: |
          # GitHub sets GITHUB_REF to refs/heads/* for branch pushes
          # and refs/tags/* for tag pushes. We only want branch pushes.
          echo "GITHUB_REF=$GITHUB_REF"
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            echo "This is a tag push; skipping workflow as per requirement.";
            exit 0;
          fi

      - name: Make sing-box executable
        shell: bash
        run: |
          if [[ -f "$SING_BOX" ]]; then
            chmod +x "$SING_BOX"
          else
            echo "Warning: sing-box binary not found at $SING_BOX (will fail on compile step if missing)"
          fi

      - name: Show sing-box version
        shell: bash
        run: |
          set -euo pipefail
          if [[ -x "$SING_BOX" ]]; then
            echo "sing-box path: $SING_BOX"
            # Try both commands; some builds support only one
            if ! "$SING_BOX" version 2>/dev/null && ! "$SING_BOX" --version 2>/dev/null; then
              echo "Note: 'sing-box version' output not available; continuing."
            fi
          else
            echo "Error: sing-box binary is not executable or missing at $SING_BOX"
            exit 1
          fi

      - name: Compute changed JSON files since last tag
        id: diff_json
        shell: bash
        run: |
          set -euo pipefail

          git fetch --tags --force

          JSON_LIST_FILE="json_list.txt"
          : > "$JSON_LIST_FILE"

          echo "Finding latest tag (if any)..."
          if git describe --tags --abbrev=0 --match '*' >/dev/null 2>&1; then
            last_tag=$(git describe --tags --abbrev=0 --match '*')
            echo "Last tag: $last_tag"

            last_tag_commit=$(git rev-list -n 1 "$last_tag")
            echo "Last tag commit: $last_tag_commit"

            # Check whether last_tag is an ancestor of current HEAD on main
            merge_base=$(git merge-base "${DEFAULT_BRANCH}" "$last_tag_commit" || true)
            echo "Merge base between $DEFAULT_BRANCH and $last_tag: $merge_base"

            if [[ -n "$merge_base" && "$merge_base" == "$last_tag_commit" ]]; then
              echo "Tag is on $DEFAULT_BRANCH ancestry; using range last_tag..HEAD"
              RANGE="$last_tag_commit..$GITHUB_SHA"
            else
              echo "Tag is not on $DEFAULT_BRANCH ancestry; using push range before..sha"
              if [[ "${GITHUB_EVENT_BEFORE:-}" != "0000000000000000000000000000000000000000" && -n "${GITHUB_EVENT_BEFORE:-}" ]]; then
                RANGE="$GITHUB_EVENT_BEFORE..$GITHUB_SHA"
              else
                echo "No valid before SHA (likely first push); using all tracked JSON files"
                RANGE=""
              fi
            fi
          else
            echo "No tags found; falling back to push range before..sha or all JSON files."
            if [[ "${GITHUB_EVENT_BEFORE:-}" != "0000000000000000000000000000000000000000" && -n "${GITHUB_EVENT_BEFORE:-}" ]]; then
              RANGE="$GITHUB_EVENT_BEFORE..$GITHUB_SHA"
            else
              echo "No valid before SHA (likely first push); using all tracked JSON files"
              RANGE=""
            fi
          fi

          echo "Using range: ${RANGE:-<none, using ls-files>}"

          if [[ -n "${RANGE}" ]]; then
            git diff --name-only "$RANGE" \
              | grep '\.json$' \
              | sort -u \
              > "$JSON_LIST_FILE" || true
          else
            # No meaningful range (e.g., first push), treat all tracked JSON as changed
            git ls-files '*.json' | sort -u > "$JSON_LIST_FILE" || true
          fi

          echo "Changed JSON files:";
          cat "$JSON_LIST_FILE" || echo "<none>"

          echo "json_list_file=$JSON_LIST_FILE" >> "$GITHUB_OUTPUT"

      - name: Compile changed JSON files with sing-box
        id: compile_json
        shell: bash
        run: |
          set -euo pipefail

          JSON_LIST_FILE="${{ steps.diff_json.outputs.json_list_file }}"

          if [[ ! -f "$JSON_LIST_FILE" ]]; then
            echo "JSON list file not found; nothing to compile."
            exit 0
          fi

          if [[ ! -s "$JSON_LIST_FILE" ]]; then
            echo "No changed JSON files detected; skipping compilation."
            exit 0
          fi

          echo "Compiling JSON files listed in $JSON_LIST_FILE..."
          while IFS= read -r jsonFile; do
            [[ -z "$jsonFile" ]] && continue
            if [[ ! -f "$jsonFile" ]]; then
              echo "Warning: listed JSON file does not exist: $jsonFile" >&2
              continue
            fi
            echo "Compiling: $jsonFile"
            # Explicitly set output path to ensure .srs is written alongside the JSON
            outFile="${jsonFile%.json}.srs"
            "$SING_BOX" rule-set compile -o "$outFile" "$jsonFile"
          done < "$JSON_LIST_FILE"

      - name: List compiled srs files and count
        id: list_srs
        shell: bash
        run: |
          set -euo pipefail

          JSON_LIST_FILE="${{ steps.diff_json.outputs.json_list_file }}"

          if [[ ! -f "$JSON_LIST_FILE" || ! -s "$JSON_LIST_FILE" ]]; then
            echo "No JSONs to compile; no .srs expected."
            echo "srs_count=0" >> "$GITHUB_OUTPUT"
            echo "srs_list_file=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          SRS_LIST_FILE="srs_list.txt"
          : > "$SRS_LIST_FILE"

          echo "Listing compiled .srs files corresponding to JSON list..."
          while IFS= read -r jsonFile; do
            [[ -z "$jsonFile" ]] && continue
            srsFile="${jsonFile%.json}.srs"
            if [[ -f "$srsFile" ]]; then
              echo "$srsFile" | tee -a "$SRS_LIST_FILE"
            else
              echo "Note: expected srs not found for $jsonFile -> $srsFile" >&2
            fi
          done < "$JSON_LIST_FILE"

          count=0
          if [[ -f "$SRS_LIST_FILE" ]]; then
            count=$(wc -l < "$SRS_LIST_FILE" | tr -d '[:space:]')
          fi

          echo "Total compiled .srs files: $count"
          echo "srs_count=$count" >> "$GITHUB_OUTPUT"
          echo "srs_list_file=$SRS_LIST_FILE" >> "$GITHUB_OUTPUT"

      - name: Commit and tag generated srs files
        if: success()
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Configure git identity for the workflow
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Stage only the compiled .srs files listed by previous step to avoid pathspec errors
          SRS_LIST_FILE="${{ steps.list_srs.outputs.srs_list_file }}"
          if [[ -n "${SRS_LIST_FILE}" && -f "${SRS_LIST_FILE}" && -s "${SRS_LIST_FILE}" ]]; then
            echo "Staging files from $SRS_LIST_FILE:"
            cat "$SRS_LIST_FILE" || true
            # Use pathspec-from-file to add exact files
            git add --pathspec-from-file="$SRS_LIST_FILE" --
          else
            echo "No .srs files to stage."
          fi

          # If no changes, exit quietly
          if git diff --cached --quiet; then
            echo "No .srs changes to commit; skipping commit and tag."
            exit 0
          fi

          # Commit with fixed message
          git commit -m "auto workflows"

          # Create/force-lightweight tag 'auto' on this commit
          git tag -f "auto"

          # Push commit and tag back to origin main
          git push origin "${DEFAULT_BRANCH}"
          git push origin "auto" --force
